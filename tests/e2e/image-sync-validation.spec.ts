/**
 * Image Sync Validation Test
 * 
 * Purpose: Validates that images generated by ComfyUI properly sync to React state
 * and persist to IndexedDB, ensuring UI reflects generated keyframes.
 * 
 * Test Strategy:
 * 1. Generate keyframes for multiple scenes
 * 2. Validate images appear in UI immediately after generation
 * 3. Verify images persist to IndexedDB
 * 4. Confirm images remain after page reload
 * 5. Check console logs for sync diagnostic messages
 */

import { test, expect } from '@playwright/test';
import { dismissWelcomeDialog, ensureDirectorMode, loadStateAndWaitForHydration } from '../fixtures/test-helpers';

const mockStoryBible = {
  title: 'Image Sync Test Story',
  logline: 'A test story about image synchronization.',
  premise: 'A story to validate image synchronization between ComfyUI and React',
  genre: 'Drama',
  setting: 'Test Environment',
  characters: '**Alice**: A tester.\n**Bob**: A validator.',
  themes: ['Testing', 'Validation'],
  plotOutline: 'Act I\n- Scene 1: Setup\nAct II\n- Scene 2: Conflict\nAct III\n- Scene 3: Resolution'
};

const mockScenes = [
  {
    id: 'scene_sync_test_1',
    title: 'Opening Scene',
    summary: 'A bright sunny day in the park',
    timeline: { shots: [], shotEnhancers: {}, transitions: [], negativePrompt: '' }
  },
  {
    id: 'scene_sync_test_2',
    title: 'Conflict Scene',
    summary: 'Dark stormy night in an abandoned warehouse',
    timeline: { shots: [], shotEnhancers: {}, transitions: [], negativePrompt: '' }
  },
  {
    id: 'scene_sync_test_3',
    title: 'Resolution Scene',
    summary: 'Peaceful sunrise over the ocean',
    timeline: { shots: [], shotEnhancers: {}, transitions: [], negativePrompt: '' }
  }
];

test.describe('Image Synchronization (ComfyUI â†’ React)', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('/');
    await dismissWelcomeDialog(page);
    await ensureDirectorMode(page);
  });

  test('validates keyframe images sync to UI after generation', async ({ page }) => {
    const syncLogs: string[] = [];
    page.on('console', msg => {
      const text = msg.text();
      if (text.includes('[ImageSync]') || text.includes('âœ…')) {
        syncLogs.push(text);
      }
    });

    // SKIP: Requires real ComfyUI server and workflows configured
    // Enable with: RUN_REAL_WORKFLOWS=1 npx playwright test image-sync-validation.spec.ts
    test.skip(!process.env.RUN_REAL_WORKFLOWS, 'Requires real ComfyUI server (RUN_REAL_WORKFLOWS=1)');
    
    // Increase timeout for real generation (5 minutes)
    test.setTimeout(300000);
    
    // Load test data
    await loadStateAndWaitForHydration(page, {
      storyBible: mockStoryBible,
      scenes: mockScenes,
      workflowStage: 'director',
      directorsVision: 'Cinematic, photorealistic, high contrast'
    }, {
        expectedComponent: 'scene-navigator',
        expectedKeys: ['storyBible', 'scenes', 'workflowStage']
    });

    // Find and click "Generate Keyframes" button
    const generateButton = page.locator('[data-testid="generate-keyframes"]').first();
    await expect(generateButton).toBeVisible({ timeout: 5000 });
    await expect(generateButton).toBeEnabled();
    
    const scenesNeedingImages = mockScenes.length;
    console.log(`ðŸŽ¬ Starting generation of ${scenesNeedingImages} keyframes...`);
    
    await generateButton.click();

    // Wait for generation to complete (3 scenes Ã— ~30s each = ~90s max)
    await page.waitForTimeout(2000); // Initial delay for first scene to start

    // Monitor each scene's image appearance
    for (let i = 0; i < mockScenes.length; i++) {
      const scene = mockScenes[i];
      if (!scene) continue;
      console.log(`â³ Waiting for scene ${i + 1}/${mockScenes.length}: "${scene.title}"`);

      // Wait for scene image to appear in SceneNavigator
      const sceneImage = page.locator(`img[alt*="${scene.title}"]`).first();
      
      try {
        // Check for error toasts first
        const errorToast = page.locator('.toast-error');
        if (await errorToast.isVisible()) {
            console.error('âŒ Error toast detected:', await errorToast.textContent());
        }

        await sceneImage.waitFor({ state: 'visible', timeout: 120000 });
        console.log(`âœ… Scene ${i + 1} image appeared in UI`);

        // Verify image has valid data URL
        const imgSrc = await sceneImage.getAttribute('src');
        expect(imgSrc).toContain('data:image');
        expect(imgSrc).toMatch(/^data:image\/(png|jpeg);base64,/);
        console.log(`âœ… Scene ${i + 1} has valid base64 data URL (${imgSrc?.slice(0, 50)}...)`);

      } catch (error) {
        console.error(`âŒ Scene ${i + 1} image did not appear in UI within 120s`);
        
        // Diagnostic: Check if image exists in IndexedDB
        const dbImages = await page.evaluate(async () => {
          const dbName = 'cinematic-story-db';
          return new Promise((resolve) => {
            const request = indexedDB.open(dbName);
            request.onsuccess = () => {
              const db = request.result;
              const tx = db.transaction('misc', 'readonly');
              const store = tx.objectStore('misc');
              const getRequest = store.get('generatedImages');
              getRequest.onsuccess = () => resolve(getRequest.result);
            };
          });
        });
        console.log('ðŸ“Š IndexedDB generatedImages:', JSON.stringify(dbImages, null, 2));
        
        throw error;
      }
    }

    // Final validation: Check all images are in state
    const finalImagesState = await page.evaluate(() => {
      return new Promise((resolve) => {
        const dbName = 'cinematic-story-db';
        const request = indexedDB.open(dbName);
        request.onsuccess = () => {
          const db = request.result;
          const tx = db.transaction('misc', 'readonly');
          const store = tx.objectStore('misc');
          const getRequest = store.get('generatedImages');
          getRequest.onsuccess = () => resolve(getRequest.result);
        };
      });
    });

    console.log(`ðŸ“Š Final IndexedDB state: ${JSON.stringify(Object.keys(finalImagesState || {}))}`);
    
    mockScenes.forEach(scene => {
      const hasImage = finalImagesState && (finalImagesState as any)[scene.id];
      expect(hasImage, `Scene "${scene.title}" should have image in IndexedDB`).toBeTruthy();
      console.log(`âœ… Scene "${scene.title}" persisted to IndexedDB`);
    });

    // Validate sync logs
    expect(syncLogs.length).toBeGreaterThan(0);
    console.log(`ðŸ“‹ Captured ${syncLogs.length} sync log messages`);
    
    // Each scene should have a success log
    mockScenes.forEach(scene => {
      const sceneLog = syncLogs.find(log => log.includes(scene.id) && log.includes('âœ…'));
      expect(sceneLog, `Should have success log for scene "${scene.title}"`).toBeTruthy();
    });
  });

  test.skip('validates images persist after page reload', async ({ page }) => {
    // SKIP: Requires real ComfyUI server and pre-generated images
    
    // Step 1: Generate images (similar to above test)
    await loadStateAndWaitForHydration(page, {
      storyBible: mockStoryBible,
      scenes: mockScenes,
      workflowStage: 'director',
      directorsVision: 'Cinematic, photorealistic'
    });

    // Pre-populate IndexedDB with mock images
    await page.evaluate((scenes) => {
      const mockImage = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+M9QDwADhgGAWjR9awAAAABJRU5ErkJggg==';
      const images: Record<string, string> = {};
      scenes.forEach((scene: any) => {
        images[scene.id] = mockImage;
      });

      const dbName = 'cinematic-story-db';
      const request = indexedDB.open(dbName);
      request.onsuccess = () => {
        const db = request.result;
        const tx = db.transaction('misc', 'readwrite');
        const store = tx.objectStore('misc');
        store.put(images, 'generatedImages');
      };
    }, mockScenes);

    // Wait for state to sync
    await page.waitForTimeout(500);

    // Verify images are visible
    for (const scene of mockScenes) {
      const sceneImage = page.locator(`img[alt*="${scene.title}"]`).first();
      await expect(sceneImage).toBeVisible({ timeout: 3000 });
    }

    console.log('âœ… All images visible before reload');

    // Step 2: Reload page
    await page.reload();
    await dismissWelcomeDialog(page);
    await ensureDirectorMode(page);
    
    // Wait for hydration
    await page.waitForTimeout(1000);

    // Step 3: Verify images still visible after reload
    for (const scene of mockScenes) {
      const sceneImage = page.locator(`img[alt*="${scene.title}"]`).first();
      await expect(sceneImage).toBeVisible({ timeout: 5000 });
      
      const imgSrc = await sceneImage.getAttribute('src');
      expect(imgSrc).toContain('data:image');
      console.log(`âœ… Scene "${scene.title}" persisted after reload`);
    }

    console.log('âœ… All images persisted correctly after page reload');
  });

  test('validates generatedImages state structure', async ({ page }) => {
    // This test can run without ComfyUI - just validates state structure
    
    await loadStateAndWaitForHydration(page, {
      storyBible: mockStoryBible,
      scenes: mockScenes,
      workflowStage: 'director'
    });

    // Check IndexedDB schema
    const dbSchema = await page.evaluate(() => {
      return new Promise((resolve) => {
        const dbName = 'cinematic-story-db';
        const request = indexedDB.open(dbName);
        request.onsuccess = () => {
          const db = request.result;
          const stores = Array.from(db.objectStoreNames);
          resolve({ stores, version: db.version });
        };
      });
    });

    expect((dbSchema as any).stores).toContain('misc');
    console.log('âœ… IndexedDB has "misc" store for generatedImages');

    // Inject test images and verify structure
    await page.evaluate((scenes) => {
      const mockImage = 'data:image/png;base64,TEST';
      const images: Record<string, string> = {};
      scenes.forEach((scene: any) => {
        images[scene.id] = mockImage;
      });

      const dbName = 'cinematic-story-db';
      const request = indexedDB.open(dbName);
      request.onsuccess = () => {
        const db = request.result;
        const tx = db.transaction('misc', 'readwrite');
        const store = tx.objectStore('misc');
        store.put(images, 'generatedImages');
      };
    }, mockScenes);

    await page.waitForTimeout(500);

    // Read back and validate
    const storedImages = await page.evaluate(() => {
      return new Promise((resolve) => {
        const dbName = 'cinematic-story-db';
        const request = indexedDB.open(dbName);
        request.onsuccess = () => {
          const db = request.result;
          const tx = db.transaction('misc', 'readonly');
          const store = tx.objectStore('misc');
          const getRequest = store.get('generatedImages');
          getRequest.onsuccess = () => resolve(getRequest.result);
        };
      });
    });

    expect(storedImages).toBeTruthy();
    expect(typeof storedImages).toBe('object');
    
    mockScenes.forEach(scene => {
      expect((storedImages as any)[scene.id]).toBe('data:image/png;base64,TEST');
    });

    console.log('âœ… generatedImages state structure is valid');
  });
});
